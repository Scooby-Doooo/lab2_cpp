# Звіт

**Варіант:** 9 (merge)  
**Дата:** 19 жовтня 2025

---

## Як тестував
- **CPU:** 16 потоків (Intel/AMD)
- **Компілятор:** MSVC 19.x (Visual Studio 2022)
- **Режим:** Release x64
- **Дані:** 100K, 1M, 10M відсортованих цілих чисел (int32_t)
- **Метод:** Кожен тест — 5 запусків, середнє значення

---

## Що показав std::merge

Базовий `std::merge` працює стабільно, час росте майже лінійно з розміром даних:

| Розмір | Час (ms) | Час/елемент (нс) |
|--------|----------|------------------|
| 100K   | 0.7      | 7.0              |
| 1M     | 6.9      | 6.9              |
| 10M    | 69.8     | 7.0              |

---

## Чи допомагають execution policies?

Протестував `std::execution::seq`, `par`, `par_unseq` на 10M елементів:

| Політика      | Час (ms) | Speedup | Примітка                    |
|---------------|----------|---------|------------------------------|
| Sequential    | 69.8     | 1.00x   | Базова лінія                 |
| seq           | 73.3     | 0.95x   | Overhead від execution policy|
| par           | 74.5     | 0.94x   | Паралелізм не дає виграшу    |
| par_unseq     | 72.8     | 0.96x   | Ледь гірше за baseline       |

**Висновок:** Execution policies для `merge` шкодять продуктивності. Overhead від паралелізації перевищує користь.

---

## Власний паралельний merge (K-потоків)

Розбивав дані на K частин, кожна частина обробляється в окремому потоці, потім результати зводяться послідовно.

### Результати для різних рівнів оптимізації:

#### **O0 (без оптимізації):**
| K  | Час (ms) | Speedup | K / CPU_threads |
|----|----------|---------|-----------------|
| 1  | 92.3     | 1.00x   | 0.06            |
| 2  | 73.3     | 1.26x   | 0.13            |
| 4  | 56.9     | 1.62x   | 0.25            |
| 8  | 47.9     | 1.93x   | 0.50            |
| **16** | **41.0** | **2.25x** | **1.00** ← Оптимум |
| 32 | 47.9     | 1.93x   | 2.00            |
| 64 | 70.3     | 1.31x   | 4.00            |

#### **O2 (стандартна оптимізація):**
| K  | Час (ms) | Speedup | K / CPU_threads |
|----|----------|---------|-----------------|
| 1  | 95.6     | 1.00x   | 0.06            |
| 2  | 75.7     | 1.26x   | 0.13            |
| 4  | 60.0     | 1.59x   | 0.25            |
| **8** | **45.8** | **2.09x** | **0.50** ← Оптимум |
| 16 | 49.0     | 1.95x   | 1.00            |
| 32 | 65.9     | 1.45x   | 2.00            |
| 64 | 112.5    | 0.85x   | 4.00            |

#### **O3 (максимальна оптимізація):**
| K  | Час (ms) | Speedup | K / CPU_threads |
|----|----------|---------|-----------------|
| 1  | 98.5     | 1.00x   | 0.06            |
| 2  | 73.4     | 1.34x   | 0.13            |
| 4  | 54.5     | 1.81x   | 0.25            |
| 8  | 46.2     | 2.13x   | 0.50            |
| 16 | 42.9     | 2.30x   | 1.00            |
| **32** | **41.7** | **2.36x** | **2.00** ← Оптимум |
| 64 | 59.3     | 1.66x   | 4.00            |

---

## Порівняння рівнів оптимізації компілятора

Протестував **три рівні оптимізації** (без оптимізації, стандартна, максимальна):

| Параметр                | O0 | O2 | O3 | Висновок        |
|-------------------------|----------------------|-----------------|------------------|-----------------|
| **Sequential merge**    | 71.1 ms              | 71.2 ms         | 69.8 ms          | ~Однаково       |
| **Optimal K**           | 16                   | 8               | 32               | **Різний!**     |
| **Best time (K=opt)**   | 41.0 ms              | 45.8 ms         | 41.7 ms          | O0 ≈ O3 > O2    |
| **Max speedup**         | 2.25x                | 2.09x           | 2.36x            | O3 найкраще     |
| **K / CPU_threads**     | 1.00 (дорівнює)      | 0.50 (половина) | 2.00 (подвійно)  | Залежить від -O |

### Ключові спостереження:

1. **Sequential merge НЕ залежить від оптимізації** (~70 ms на всіх рівнях)
   - Merge обмежений пропускною здатністю пам'яті, а не CPU
   - Компілятор не може прискорити читання/запис у RAM

2. **Optimal K СИЛЬНО залежить від оптимізації:**
   - **O0:** Optimal K = CPU_threads (16)
     - Код неоптимізований → паралелізм завжди вигідний
   - **O2:** Optimal K = CPU_threads / 2 (8)
     - Збалансовано: код швидший, але thread overhead стає помітним
   - **O3:** Optimal K = CPU_threads × 2 (32)
     - Код настільки швидкий, що може використати hyperthreading

3. **Speedup майже однаковий** (2.09x - 2.36x)
   - Паралельний merge дає ~2.3x прискорення незалежно від -O

---

## Висновки

### 1. Execution policies (`std::execution::par`)
- **Не ефективні** для `std::merge`
- Overhead від паралелізації перевищує користь
- На практиці **повільніше** за звичайний merge

### 2. Власний паралельний merge
- **До 2.36x швидше** за sequential merge
- Optimal K залежить від рівня оптимізації компілятора
- Надмірний паралелізм шкодить через:
  - Перевантаження кешу
  - Thread context switching overhead
  - Memory bandwidth saturation

### 3. Вплив compiler optimization
- **Sequential merge:** оптимізація НЕ впливає (~70 ms)
  - Memory-bound операція
- **Parallel merge:** оптимізація змінює стратегію
  - O0: використовуйте K = CPU_threads
  - O2: використовуйте K = CPU_threads / 2
  - O3: можна використати K = CPU_threads × 2 (hyperthreading)

### 4. Закон зростання часу
- **До optimal K:** час зменшується експоненційно
- **Після optimal K:** час зростає лінійно з K
- **Причина:** фіксований час на злиття K результатів

---

## Структура програми

### Класи:
- **IMergeStrategy** — інтерфейс стратегії merge
- **SequentialMergeStrategy** — стандартний `std::merge`
- **ParallelMergeStrategy** — власний паралельний merge
- **BenchmarkRunner** — вимірювання часу виконання
- **ExperimentRunner** — запуск експериментів
- **DataGenerator** — генерація тестових даних
- **OutputFormatter** — форматований вивід результатів

---

**Дата виконання:** 19 жовтня 2025  
**Компілятор:** MSVC 19.x (Visual Studio 2022)  
**Режими компіляції:** O0 (Debug), O2 (Release), O3 (Release + агресивна оптимізація)  
**Платформа:** Windows x64
